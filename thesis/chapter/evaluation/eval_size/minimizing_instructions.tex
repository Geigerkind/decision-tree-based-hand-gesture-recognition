\subsection{Minimierung der Instruktionen eines Vergleichs}
Das Ziel ist mit so wenig Instruktionen wie möglich einen Vergleich darzustellen. In Sektion \ref{sec:cCodeTree} wurde
bereits gezeigt, wie C-Code aus den Entscheidungsbäumen generiert wird.
\begin{lstlisting}[label=lst:assemblyVergleich,caption={Vergleich von Gleitkommazahl-Feature mit konstanter Gleitkommazahl.}]
01: ldi r18,lo8(33)
02: ldi r19,lo8(-92)
03: ldi r20,lo8(69)
04: ldi r21,lo8(60)
05: ldd r26,Y+5
06: ldd r27,Y+6
07: adiw r26,36
08: ld r22,X+
09: ld r23,X+
10: ld r24,X+
11: ld r25,X
12: sbiw r26,36+3
13: call __lesf2
14: cp __zero_reg__,r24
15: brge .+2
\end{lstlisting}
Listing \ref{lst:assemblyVergleich} zeigt die Komplexität eines einzigen Vergleiches in Instruktionen. Zeile 1 bis 4 läd die konstante Gleitkommazahl in 4 hintereinander liegende 8-Bit Register. Zeile 5
bis 7 läd den Zeiger auf die Featuremenge und inkrementiert sie um 36 um auf das 9. Feature zuzugreifen. In Zeile 8 bis 11 wird das Feature in die Register geladen. Zeile 12 bis 15 führen die
Vergleichsfunktion aus. Insgesamt sind es 15 Instruktionen, was ziemlich teuer für einen einzigen Vergleich ist.
\newline
\newline
Zu Vermeiden sind Zeile 5 bis 11 indem alle Features nur einmal in Register geladen werden. Dies ist allerdings nur möglich, wenn die gesamte Featuremenge in die Register reinpassen und zusätzlich
noch Register verfügbar sind, um die Konstanten zu laden. Der Kompiler übernimmt diese Optimierung schon automatisch. Der ATmega328P verfügt allerdings nur über 32 Register.
Bei einer Featuremenge von 10 werden dementsprechend regelmäßig Register verdrängt wodurch zusätzliche Instruktionen entstehen. Die Anzahl der Instruktionen können also reduziert werden, indem
die Featuremenge reduziert wird bei der gleichen Anzahl von Vergleichen.
\begin{lstlisting}[label=lst:assemblyVergleich8Bit,caption={Vergleich von 8-Bit-Feature mit konstanter 8-Bit Zahl.}]
01: adiw r26,4
02: ld r24,X
03: sbiw r26,4
04: cpi r24,lo8(124)
05: brge .L3
\end{lstlisting}
Zusätzlich ist die Gleitkommazahl sehr teuer für einen 8-Bit Prozessor. Es werden immer 4 Register benötigt und zusätzliche Funktionen die die fehlende Hardwareunterstützung ausgleichen. Idealerweise sollte
für die Featuremenge und die Vergleiche ein 8-Bit Datentyp gewählt werden. Damit werden einerseits weniger Register benötigt, wodurch wiederrum die Featuremenge größer sein kann, und andererseits können
native Vergleichsinstruktionen benutzt werden. Dies verringert die Anzahl der Instruktionen signifikant und eleminiert die teuere Gleitkommazahlvergleichsfunktion. Mit einem kleinern Datentyp können
dementsprechend Instruktionen vermieden werden. Listing \ref{lst:assemblyVergleich8Bit} zeigt einen Vergleich mit einem 8-Bit Datentyp. Insgesamt werden $66,6\%$ weniger Instruktionen benötigt.

\iffalse
* Alle features in register laden am Anfang
    => Limitiert durch Register Anzahl im ATmega328P
    => Also nicht machbar mit jeder Featuremenge
* Typ auswahl: 8-Bit Prozessor, also am besten 8 Bit integer für native Vergleiche ohne Hilfsfunktionen
    => Verschnellert den Baum auch drastisch
    => Dies ist abhängig von der Featuremenge
    => Note für Float Features gehen pro Feature 4 Register drauf.
    => Alles was drüber geht wird von dem Compiler eleminiert oder erzeugt stack instruktionen, was wiederrum den Sinn und Zweck vernichtet.
* Voting Algo: Scikit-learn addiert die Wahrscheinlichkeiten, da dies sich als besser erwiesen hat.
    => Allerdings ist implementierung sehr Teuer was instruktionen angeht
    => Diskretes Voten ist Günstiger
\fi